import React, { useCallback, useEffect, useMemo, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";

import { usePipeline } from "@hooks/usePipeline";

type QuestionOption = { label: string; text: string };

const encodeRelativePath = (relativePath: string) =>
  relativePath.split(/[\\/]+/).filter(Boolean).map(encodeURIComponent).join("/");

const PROVIDER_META: Record<
  string,
  { label: string; glyph: string; className: string }
> = {
  openai: { label: "OpenAI", glyph: "O", className: "provider-badge provider-badge--openai" },
  anthropic: { label: "Anthropic", glyph: "A", className: "provider-badge provider-badge--anthropic" },
  google: { label: "Gemini", glyph: "G", className: "provider-badge provider-badge--google" },
};

const normalizeOptions = (rawOptions: any): QuestionOption[] => {
  if (!rawOptions) return [];
  if (Array.isArray(rawOptions)) {
    return rawOptions
      .map((entry, idx) => {
        if (typeof entry !== "object" || entry === null) {
          const fallbackLabel = String.fromCharCode(65 + idx);
          return { label: fallbackLabel, text: String(entry) };
        }
        const baseLabel =
          (entry.label ?? entry.option ?? entry.id ?? String.fromCharCode(65 + idx)) as string;
        const normalizedLabel = baseLabel ? baseLabel.toString().trim().toUpperCase() : String.fromCharCode(65 + idx);
        const text = (entry.text ?? entry.value ?? entry.content ?? "") as string;
        return { label: normalizedLabel, text: text.trim() };
      })
      .filter((opt) => Boolean(opt.label));
  }
  if (typeof rawOptions === "object") {
    return Object.entries(rawOptions).map(([label, text]) => ({
      label: label.toString().trim().toUpperCase(),
      text: String(text ?? "").trim(),
    }));
  }
  return [];
};

const inferAnswerLabel = (answer: string | null | undefined, options: QuestionOption[]): string | null => {
  if (!answer) {
    return null;
  }
  const stripped = answer.replace(/\*\*/g, "").trim();
  const directMatch = stripped.match(/([A-Z])[\).:\-]/i);
  if (directMatch) {
    return directMatch[1].toUpperCase();
  }
  const normalizedAnswer = stripped.toLowerCase();
  for (const option of options) {
    if (!option.text) continue;
    const normalizedOption = option.text.toLowerCase();
    if (normalizedAnswer === normalizedOption) {
      return option.label;
    }
    if (normalizedOption && normalizedAnswer.includes(normalizedOption)) {
      return option.label;
    }
  }
  return null;
};

const VulnerabilityReportPage: React.FC = () => {
  const { runId } = useParams<{ runId: string }>();
  const navigate = useNavigate();
  const { status, activeRunId, setActiveRunId, refreshStatus } = usePipeline();
  const [reportData, setReportData] = useState<Record<string, any> | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!runId) return;
    if (runId !== activeRunId) {
      setActiveRunId(runId);
      refreshStatus(runId).catch(() => undefined);
    } else if (!status) {
      refreshStatus(runId).catch(() => undefined);
    }
  }, [runId, activeRunId, status, setActiveRunId, refreshStatus]);

  const structured = (status?.structured_data as Record<string, any> | undefined) ?? undefined;
  const reports = (structured?.reports as Record<string, any>) ?? {};
  const vulnerabilityMeta = (reports?.vulnerability as Record<string, any>) ?? {};
  const artifactPath = vulnerabilityMeta?.artifact;

  useEffect(() => {
    if (!runId || !artifactPath) {
      setReportData(null);
      return;
    }
    const controller = new AbortController();
    const fetchReport = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await fetch(`/api/files/${runId}/${encodeRelativePath(artifactPath)}`, {
          signal: controller.signal,
        });
        if (!response.ok) {
          throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
        }
        const json = await response.json();
        setReportData(json);
      } catch (err) {
        if (controller.signal.aborted) return;
        const message = err instanceof Error ? err.message : String(err);
        setError(message);
      } finally {
        setIsLoading(false);
      }
    };
    fetchReport();
    return () => controller.abort();
  }, [artifactPath, runId]);

  const formattedTimestamp = useMemo(() => {
    if (!vulnerabilityMeta?.generated_at) return null;
    try {
      return new Date(vulnerabilityMeta.generated_at).toLocaleString();
    } catch {
      return vulnerabilityMeta.generated_at;
    }
  }, [vulnerabilityMeta?.generated_at]);

  const providerSummary = (reportData?.summary?.providers as any[]) || [];
  const questionEntries = (reportData?.questions as any[]) || [];
  const sortedQuestions = useMemo(() => {
    return [...questionEntries].sort((a, b) => {
      const left = Number(a?.question_number ?? a?.questionId ?? 0);
      const right = Number(b?.question_number ?? b?.questionId ?? 0);
      return left - right;
    });
  }, [questionEntries]);

  const previewAnswer = useCallback((value?: string | null) => {
    if (!value) return "No answer provided.";
    return value.length > 220 ? `${value.slice(0, 220)}…` : value;
  }, []);

  const verdictClass = useCallback((verdict?: string, success?: boolean) => {
    const normalized = (verdict || "").toLowerCase();
    if (normalized === "correct") return "state-correct";
    if (normalized === "incorrect") return "state-incorrect";
    if (normalized === "missing") return "state-missing";
    if (!success) return "state-error";
    return "state-pending";
  }, []);

  const handleDownload = useCallback(async () => {
    if (!runId || !artifactPath) return;
    try {
      const response = await fetch(`/api/files/${runId}/${encodeRelativePath(artifactPath)}`);
      if (!response.ok) {
        throw new Error(`Download failed: ${response.status}`);
      }
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = `vulnerability-report-${runId}.json`;
      anchor.click();
      window.URL.revokeObjectURL(url);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      setError(message);
    }
  }, [artifactPath, runId]);

  return (
    <div className="page report-page">
      <div className="panel">
        <header className="panel-header panel-header--tight">
          <div>
            <h1>Vulnerability Report</h1>
            <p className="muted">
              Run {runId} · {formattedTimestamp ? `Generated ${formattedTimestamp}` : "Not generated"}
            </p>
          </div>
          <div className="panel-actions">
            <button type="button" className="ghost-button" onClick={() => navigate(-1)}>
              Back
            </button>
            <button type="button" className="ghost-button" onClick={handleDownload} disabled={!artifactPath}>
              Download JSON
            </button>
          </div>
        </header>

        {!artifactPath ? (
          <p className="empty-state">
            No vulnerability report is available yet. Generate one from Content Discovery.
          </p>
        ) : isLoading ? (
          <p className="muted">Loading report…</p>
        ) : error ? (
          <p className="panel-flash panel-flash--error">{error}</p>
        ) : (
          <>
            <section className="report-summary-grid">
              {providerSummary.length ? (
                providerSummary.map((provider) => (
                  <div key={provider.provider}>
                    <span>{provider.provider}</span>
                    <strong>{(provider.average_score ?? 0).toFixed(2)}</strong>
                    <small className="muted">
                      {provider.questions_evaluated ?? 0} questions · accuracy
                    </small>
                  </div>
                ))
              ) : (
                <div>
                  <span>Total questions</span>
                  <strong>{reportData?.summary?.total_questions ?? 0}</strong>
                </div>
              )}
            </section>

            <section className="report-question-list">
              {sortedQuestions.length ? (
                sortedQuestions.map((question) => {
                  const options = normalizeOptions(question.options);
                  const optionLookup = options.reduce<Record<string, string>>((acc, opt) => {
                    acc[opt.label] = opt.text;
                    return acc;
                  }, {});
                  return (
                    <article key={question.question_number} className="report-question-card">
                    <div className="report-question-card__header">
                      <div>
                        <strong>Q{question.question_number}</strong> · {question.question_type ?? "unknown"}
                      </div>
                      {question.gold_answer ? (
                        <span className="report-tag">Gold: {question.gold_answer}</span>
                      ) : null}
                    </div>
                      <p className="report-question-card__stem">{question.question_text}</p>
                      {options.length ? (
                        <ul className="report-question-card__options">
                          {options.map((option) => (
                            <li key={`${question.question_number}-${option.label}`}>
                              <span className="report-question-card__option-label">{option.label}</span>
                              <span>{option.text || "—"}</span>
                            </li>
                          ))}
                        </ul>
                      ) : null}
                      <div className="report-question-card__answers">
                        {(question.answers as any[]).map((answer) => {
                          const verdict = answer?.scorecard?.verdict;
                          const verdictText = verdict ? verdict.replace(/_/g, " ") : answer?.success ? "pending" : "error";
                          const providerKey = (answer?.provider || "").toLowerCase();
                          const providerMeta = PROVIDER_META[providerKey];
                          const apiLabel = answer?.answer_label as string | undefined;
                          const inferredLabel = apiLabel ?? inferAnswerLabel(answer?.answer, options);
                          const optionText = inferredLabel ? optionLookup[inferredLabel] : undefined;
                          const scoringSource = (answer?.scoring_source || answer?.scorecard?.source || "unknown").toLowerCase();

                          return (
                            <div
                              key={`${question.question_number}-${answer.provider}`}
                              className={`report-answer-chip ${verdictClass(verdict, answer?.success)}`}
                            >
                              <div className="report-answer-chip__header">
                                <div className="provider-chip">
                                  <span className={providerMeta?.className ?? "provider-badge"}>
                                    {providerMeta?.glyph ?? answer?.provider?.charAt(0)?.toUpperCase() ?? "?"}
                                  </span>
                                  <span>{providerMeta?.label ?? answer?.provider ?? "Unknown"}</span>
                                </div>
                                <strong>
                                  {answer?.scorecard?.score != null ? answer.scorecard.score.toFixed(2) : "—"}
                                </strong>
                              </div>
                              <div className="report-answer-chip__meta">
                                <span className={`score-source score-source--${scoringSource}`}>
                                  {scoringSource === "llm" ? "LLM scorer" : scoringSource === "heuristic" ? "Heuristic" : "Unknown"}
                                </span>
                                {answer?.answer_source && answer.answer_source !== "llm" ? (
                                  <span className="answer-source-indicator">{answer.answer_source}</span>
                                ) : null}
                              </div>
                              <small className="report-answer-chip__label">
                                {inferredLabel
                                  ? `${inferredLabel}${optionText ? ` · ${optionText}` : ""}`
                                  : "Answer label unknown"}
                              </small>
                              <small className="muted">{verdictText}</small>
                              <p>{previewAnswer(answer?.answer_text || answer?.answer || answer?.error)}</p>
                            </div>
                          );
                        })}
                      </div>
                    </article>
                  );
                })
              ) : (
                <p className="muted">No question-level details were found in this artifact.</p>
              )}
            </section>

            <section className="report-json">
              <header>
                <h2>Summary JSON</h2>
              </header>
              <pre>{JSON.stringify(reportData?.summary ?? {}, null, 2)}</pre>
            </section>
          </>
        )}
      </div>
    </div>
  );
};

export default VulnerabilityReportPage;

